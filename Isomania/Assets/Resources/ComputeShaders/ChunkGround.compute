#pragma kernel TriangleBiomeSelector // kernel 0
#pragma kernel VerticeBiomeSelector // kernel 1
#pragma kernel MeshDisplacement // kernel 2
#pragma kernel NormalizeMeshTriangles // kernel 3
#pragma kernel NormalizeMeshVertices // kernel 4
#pragma kernel TriangleMidpointY // kernel 5
/*
#pragma kernel StaticTriangleType // kernel 6
#pragma kernel TriangleType // kernel 7
*/

// 
// For all kernels
//
// include fastnoise lite
#include "Assets/Graphics/CGincFiles/Noise/FastNoiseLite.cginc"

/// changing values for each dispatch
float2 meshXZPosition; // xz position of current mesh

//
// For all biome kernels
//
StructuredBuffer<fnl_state> FNLStateBiomeBuffer; // all fnlStates for biomes
StructuredBuffer<fnl_state> FNLWarpStateBiomeBuffer; // all fnlWarpStates for biomes
int biomeBufferLength; // the length of fnl state buffers (they have the same length)

//
// For all triangle kernels
//
StructuredBuffer<float2> trianglesMidPoint; // xz position for triangle midpoint
int quadCountWidth;

//
// For all vertice kernels
//
StructuredBuffer<float2> verticesExtendedXZ; // xz position for all vertices
int verticeCountWidthExtended;

//
// For TriangleBiomeSelector
//
// RW buffers that is required for TriangleBiomeSelector
RWBuffer<int> triangleBiome; // the triangles biome index

// calculates the biome for each triangle of mesh
[numthreads(61, 1, 1)] // id.x = quadCountHeight
void TriangleBiomeSelector(uint3 id : SV_DispatchThreadID)
{
    // get triangle index
    int triangleIndexOffset = id.x * quadCountWidth * 2;

    for (int x = 0; x < quadCountWidth * 2; x++)
    {
        // get triangle index
        int triangleIndex = triangleIndexOffset + x;

        // get triangle midpoint x value (from precalculated vertice array and offset)
        float x = trianglesMidPoint[triangleIndex].x + meshXZPosition.x;
        // get triangle midpoint z value (from precalculated vertice array and offset)
        float z = trianglesMidPoint[triangleIndex].y + meshXZPosition.y;

        // the warped xz values
        float xWarped;
        float zWarped;

        // set triangle biome to default (0)
        triangleBiome[triangleIndex] = 0;

        // itterate every fnl_state
        for (int i = 0; i < biomeBufferLength; i++)
        {
            // reset xz values
            xWarped = x;
            zWarped = z;
            // and warp them
            fnlDomainWarp2D(FNLWarpStateBiomeBuffer[i], xWarped, zWarped);

            // use warped xz values to get noise value
            float noiseValue = SampleNoise2D(FNLStateBiomeBuffer[i], xWarped, zWarped);

            // if this noise value is enough to trigger this triangle as this biome
            if (noiseValue > FNLStateBiomeBuffer[i].threshold_min && noiseValue < FNLStateBiomeBuffer[i].threshold_max)
            {
                // mark this triangle that biome
                triangleBiome[triangleIndex] = FNLStateBiomeBuffer[i].index;
                // and break for loop
                break;
            }
        }
    }
}

//
// For VerticeBiomeSelector
//
// RW buffers that is required for BiomeSelector
RWBuffer<int> verticeBiome; // the vertices biome index

// calculates the biome for each vertice of mesh
[numthreads(64, 1, 1)] // id.x = verticeCountHeightExtended
void VerticeBiomeSelector(uint3 id : SV_DispatchThreadID)
{
    // get vertice index
    int verticeIndexOffset = id.x * verticeCountWidthExtended;

    for (int x = 0; x < verticeCountWidthExtended; x++)
    {
        // get vertice index
        int verticeIndex = verticeIndexOffset + x;

        // get vertice x value (from precalculated vertice array and offset)
        float x = verticesExtendedXZ[verticeIndex].x + meshXZPosition.x;
        // get vertice z value (from precalculated vertice array and offset)
        float z = verticesExtendedXZ[verticeIndex].y + meshXZPosition.y;

        // the warped xz values
        float xWarped;
        float zWarped;

        // set vertice biome to default (0)
        verticeBiome[verticeIndex] = 0;

        // itterate every fnl_state
        for (int i = 0; i < biomeBufferLength; i++)
        {
            // reset xz values
            xWarped = x;
            zWarped = z;
            // and warp them
            fnlDomainWarp2D(FNLWarpStateBiomeBuffer[i], xWarped, zWarped);

            // use warped xz values to get noise value
            float noiseValue = SampleNoise2D(FNLStateBiomeBuffer[i], xWarped, zWarped);

            // if this noise value is enough to trigger this vertice as this biome
            if (noiseValue > FNLStateBiomeBuffer[i].threshold_min && noiseValue < FNLStateBiomeBuffer[i].threshold_max)
            {
                // mark this vertice that biome
                verticeBiome[verticeIndex] = FNLStateBiomeBuffer[i].index;
                // and break for loop
                break;
            }
        }
    }
}

//
// For MeshDisplacement
//
StructuredBuffer<fnl_state> FNLStateVerticeOffsetBuffer; // all fnlStates for vertice offset
StructuredBuffer<fnl_state> FNLWarpStateVerticeOffsetBuffer; // all fnlWarpStates vertice offset
int verticeOffsetBufferLength; // the length of fnl state buffers (they have the same length)

// RW buffers that is required for BiomeSelector
RWBuffer<float> verticesExtendedY; // y position for vertices, that is read write (write only doesnt excist)
RWBuffer<float> minYValues; // length of verticeCountHeight
RWBuffer<float> maxYValues; // length of verticeCountHeight

int verticeCountHeightExtended;

// calculates each vertex y-position with a excess ring of vertices (1 more vertex on each side, to account for normal calculation)
[numthreads(64, 1, 1)] // id.x = verticeCountHeightExtended
void MeshDisplacement(uint3 id : SV_DispatchThreadID)
{
    // get vertice index
    int verticeIndexOffset = id.x * verticeCountWidthExtended;

    // set minYValue and maxYValue to largest value possible
    minYValues[id.x] = 3.402823466e+38;
    maxYValues[id.x] = -3.402823466e+38;

    for (int x = 0; x < verticeCountWidthExtended; x++)
    {
        // get vertice index
        int verticeIndex = verticeIndexOffset + x;
        
        // get vertice x value (from precalculated vertice array and offset)
        float x = verticesExtendedXZ[verticeIndex].x + meshXZPosition.x;
        // get vertice z value (from precalculated vertice array and offset)
        float z = verticesExtendedXZ[verticeIndex].y + meshXZPosition.y;

        // the warped xz values
        float xWarped;
        float zWarped;
        
        // reset verticesExtendedY
        verticesExtendedY[verticeIndex] = 0;
        
        // itterate every fnl_state
        for (int i = 0; i < verticeOffsetBufferLength; i++)
        {
            // if this noise state should be evaluated for this vertice
            if (FNLStateVerticeOffsetBuffer[i].index == verticeBiome[verticeIndex])
            {
                // reset xz values
                xWarped = x;
                zWarped = z;
                // and warp them
                fnlDomainWarp2D(FNLWarpStateVerticeOffsetBuffer[i], xWarped, zWarped);

                // use warped xz values to get noise value
                verticesExtendedY[verticeIndex] += SampleNoise2D(FNLStateVerticeOffsetBuffer[i], xWarped, zWarped);
            }
        }

        // scale verticesExtendedY by masked noise

        // if we are on corners of vertice continue for loop
        if (id.x == 0 || id.x == verticeCountHeightExtended - 1 || x == 0 || x == verticeCountWidthExtended - 1)
        {
            continue;
        }

        int minMaxIndex = id.x - 1;

        // if any values are larger than the largest or smaller than the smallest value save it as new value
        if (verticesExtendedY[verticeIndex] < minYValues[minMaxIndex])
        {
            minYValues[minMaxIndex] = verticesExtendedY[verticeIndex];
        }
        if (verticesExtendedY[verticeIndex] > maxYValues[minMaxIndex])
        {
            maxYValues[minMaxIndex] = verticesExtendedY[verticeIndex];
        }
    }
}

//
// For NormalizeMeshTriangles
//
// RW buffers that is required for NormalizeMeshTriangles
RWStructuredBuffer<float3> triangleExtendedNormals; // all the triangles normals
int quadCountWidthExtended;

// calculates the normal for each triangle of extended mesh by getting the 4 vertices that make up this quad
[numthreads(63, 1, 1)] // id.x = quadCountHeightExtended
void NormalizeMeshTriangles(uint3 id : SV_DispatchThreadID)
{
    // get triangle index
    int triangleIndexOffset = id.x * quadCountWidthExtended * 2;

    // get the indicees for verticees row
    int verticeIndexBot = id.x * verticeCountWidthExtended;
    int verticeIndexTop = (id.x + 1) * verticeCountWidthExtended;

    for (int x = 0; x < quadCountWidthExtended; x++)
    {
        // get the indicees for verticees col
        int verticeIndexLeft = x;
        int verticeIndexRight = x + 1;

        // using indicees for row and col get verticees indicees for all four corner indices
        int verticeIndexBL = verticeIndexBot + verticeIndexLeft;
        int verticeIndexTL = verticeIndexTop + verticeIndexLeft;
        int verticeIndexBR = verticeIndexBot + verticeIndexRight;
        int verticeIndexTR = verticeIndexTop + verticeIndexRight;

        // using corner indices get the vertex values
        float3 verticeBL = float3(verticesExtendedXZ[verticeIndexBL].x, verticesExtendedY[verticeIndexBL], verticesExtendedXZ[verticeIndexBL].y);
        float3 verticeTL = float3(verticesExtendedXZ[verticeIndexTL].x, verticesExtendedY[verticeIndexTL], verticesExtendedXZ[verticeIndexTL].y);
        float3 verticeBR = float3(verticesExtendedXZ[verticeIndexBR].x, verticesExtendedY[verticeIndexBR], verticesExtendedXZ[verticeIndexBR].y);
        float3 verticeTR = float3(verticesExtendedXZ[verticeIndexTR].x, verticesExtendedY[verticeIndexTR], verticesExtendedXZ[verticeIndexTR].y);

        // get both triangle indices for this quad
        int triangleIndex0 = triangleIndexOffset + x * 2;
        int triangleIndex1 = triangleIndex0 + 1;

        // using all four corners vertice indices calculate triangle normals for both triangles of quad
        triangleExtendedNormals[triangleIndex0] = normalize(
            cross(
                verticeTL - verticeBL,
                verticeBR - verticeBL
            )
        );
        triangleExtendedNormals[triangleIndex1] = normalize(
            cross(
                verticeTR - verticeTL,
                verticeBR - verticeTL
            )
        );
    }
}

//
// For NormalizeMeshVertices
//
// RW buffers that is required for NormalizeMeshVertices
RWStructuredBuffer<float3> verticesNormals; // all the triangles normals
int verticeCountWidth;

// takes the average of the 6 neighbouring triangle normals to get vertice normal, ignoring setting normals on the outer ring of vertices
[numthreads(62, 1, 1)] // id.x = verticeCountHeight
void NormalizeMeshVertices(uint3 id : SV_DispatchThreadID)
{
    // get vertice index
    int verticeIndexOffset = id.x * verticeCountWidth;

    // get bottom row of triangles index for the 3 bottom half of triangles
    int triangleBottomIndex = id.x * quadCountWidthExtended * 2;

    // get upper row of triangles index for the 3 upper half of triangles
    int triangleUpperIndex = (id.x + 1) * quadCountWidthExtended * 2;

    for (int x = 0; x < verticeCountWidth; x++)
    {
        // get first triangle index for bottom and upper, the next follow, +1,+2,+3
        int triangleColStartIndex = x * 2;

        int firstTriangleBottomIndex = triangleBottomIndex + triangleColStartIndex;
        int firstTriangleUpperIndex = triangleUpperIndex + triangleColStartIndex;

        // get vertice index
        int verticeIndex = verticeIndexOffset + x;

        // calculate smooth vertice normal by taking the average of the 6 nearby triangle normals and normalize
        verticesNormals[verticeIndex] = normalize(
            (
                triangleExtendedNormals[firstTriangleBottomIndex + 1] +
                triangleExtendedNormals[firstTriangleBottomIndex + 2] +
                triangleExtendedNormals[firstTriangleBottomIndex + 3] +

                triangleExtendedNormals[firstTriangleUpperIndex] +
                triangleExtendedNormals[firstTriangleUpperIndex + 1] +
                triangleExtendedNormals[firstTriangleUpperIndex + 2]
            ) / 6.0
        );
    }
}

//
// For TriangleMidpointY
//
// RW buffers that is required for TriangleMidpointY
RWBuffer<float> triangleMidpointY; // length of triangleCount

// calculates triangle midpoint y and saves the largest and smallest y value for the thread, itterated later on by the cpu to get bounds of mesh
[numthreads(61, 1, 1)] // id.x = quadCountHeight
void TriangleMidpointY(uint3 id : SV_DispatchThreadID)
{
    // get triangle index
    int triangleIndexOffset = id.x * quadCountWidth * 2;

    // get the indicees for verticees row
    int verticeIndexBot = id.x * verticeCountWidthExtended;
    int verticeIndexTop = (id.x + 1) * verticeCountWidthExtended;

    for (int x = 0; x < quadCountWidth; x++)
    {
        // get the indicees for verticees col
        int verticeIndexLeft = id.x;
        int verticeIndexRight = id.x + 1;

        // using indicees for row and col get verticees indicees for all four corner indices
        int verticeIndexBL = verticeIndexBot + verticeIndexLeft;
        int verticeIndexTL = verticeIndexTop + verticeIndexLeft;
        int verticeIndexBR = verticeIndexBot + verticeIndexRight;
        int verticeIndexTR = verticeIndexTop + verticeIndexRight;

        // get both triangle indices for this quad
        int triangleIndex0 = triangleIndexOffset + x * 2;
        int triangleIndex1 = triangleIndex0 + 1;

        // using all four corners vertice indices calculate triangle midpoint y for both triangles of quad
        triangleMidpointY[triangleIndex0] = (
            verticesExtendedY[verticeIndexBL] + 
            verticesExtendedY[verticeIndexTL] + 
            verticesExtendedY[verticeIndexBR]
        ) / 3.0;

        triangleMidpointY[triangleIndex1] = (
            verticesExtendedY[verticeIndexBL] + 
            verticesExtendedY[verticeIndexTL] + 
            verticesExtendedY[verticeIndexBR]
        ) / 3.0;
    }
}

/*
// changes the underlying submesh index by triangle normal and y value, used to create mountainous or underwater terrain
[numthreads(64, 1, 1)]
void StaticTriangleType(uint3 id : SV_DispatchThreadID)
{

}

// uses triangle type to get 
[numthreads(64, 1, 1)]
void TriangleType(uint3 id : SV_DispatchThreadID)
{
    // uses 
}
*/